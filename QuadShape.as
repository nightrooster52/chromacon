package {	import flash.display.Sprite;	import flash.geom.Point;				public class QuadShape extends Sprite {		public var main:Prototype;		public var degrees:int;		public var shape:Number;		public var color:String;		private var block1:Block = new Block();		private var block2:Block = new Block();		private var block3:Block = new Block();		private var block4:Block = new Block();		public var blockArray:Array = [block1, block2, block3, block4];		//constructor code		//generates random fields		public function QuadShape(main:Prototype) {									this.main = main;			this.mouseChildren = false;			this.mouseEnabled = false;			shape = Math.random();			degrees = Math.random() * 4;			degrees *=  90;						this.scaleX = .3;			this.scaleY = .3;					init();		}				//init function		//transforms blocks according to fields (shape, degrees		public function init():void {						for (var i:uint =0; i < 4; i++){				blockArray[i].scaleX *= main.blockSize/blockArray[i].width;				blockArray[i].scaleY *= main.blockSize/blockArray[i].height;			}									if (shape < 1/7) {				//trace("T");				tShape();			}			else if (shape < 2/7) {				//trace("L");				lShape();			}			else if (shape < 3/7) {				//trace("O");				oShape();			}			else if (shape < 4/7) {				//trace("J");				jShape();			}			else if (shape < 5/7) {				//trace("S");				sShape();			}			else if (shape < 6/7) {				//trace("Z");				zShape();			}			else {				//trace("Long");				longShape();			}									while (numChildren > 0){				removeChildAt(0);			}			rotate(degrees);			positionBlocks();						addChild(block1);			addChild(block2);			addChild(block3);			addChild(block4);		}						public function rotateHit():void{			degrees = (degrees + 90)%360;			init();					}		public function rotate(degrees:int):void {			if (degrees == 90){				rotate90Degrees(block2);				rotate90Degrees(block3);				rotate90Degrees(block4);							}else if(degrees == 180){				rotate90Degrees(block2);				rotate90Degrees(block3);				rotate90Degrees(block4);								rotate90Degrees(block2);				rotate90Degrees(block3);				rotate90Degrees(block4);							}else if(degrees == 270){				rotate90Degrees(block2);				rotate90Degrees(block3);				rotate90Degrees(block4);								rotate90Degrees(block2);				rotate90Degrees(block3);				rotate90Degrees(block4);								rotate90Degrees(block2);				rotate90Degrees(block3);				rotate90Degrees(block4);							}			positionBlocks();		}				private function rotate90Degrees(block:Block):void{			var newBoardX:int = -block.boardY;			var newBoardY:int = block.boardX;						block.boardX = newBoardX;			block.boardY = newBoardY;		}				private function longShape():void {			block2.boardX = 1;			block3.boardX = 2;			block4.boardX = 3;		}		private function zShape():void {			sShape();			block2.boardX *= -1;			block3.boardX *= -1;			block4.boardX *= -1;		}		private function sShape():void {			block2.boardX = 1;			block3.boardX = 1;			block3.boardY = 1;			block4.boardX = 2;			block4.boardY = 1;		}				private function jShape():void {			lShape();			block2.boardX *= -1;			block3.boardX *= -1;			block4.boardX *= -1;		}				private function tShape():void {			block2.boardX = 1;			block3.boardX = 1;			block3.boardY = 1;			block4.boardX = 2;		}				private function lShape():void {			block2.boardY = 1;			block3.boardY = 2;			block4.boardX = 1;			block4.boardY = 2;		}				private function oShape():void {			block2.boardY = 1;			block3.boardX = 1;			block4.boardX = 1;			block4.boardY = 1;					}		private function positionBlocks():void{			block2.x = block2.boardX*main.blockSize;			block2.y = block2.boardY*main.blockSize;			block3.x = block3.boardX*main.blockSize;			block3.y = block3.boardY*main.blockSize;			block4.x = block4.boardX*main.blockSize;			block4.y = block4.boardY*main.blockSize;		}				private function removeBlocks():void {			removeChild(block1);			removeChild(block2);			removeChild(block3);			removeChild(block4);		}				//makes the blocks into the same color as the quadshape		public function resetBlockColors():void{			block1.type = this.color;			block2.type = this.color;			block3.type = this.color;			block4.type = this.color;			reSkinBlocks();		}		//calls the blocks to color themselves appropriately		public function reSkinBlocks():void{			//trace("reskin blocks");			block1.reSkin();			block2.reSkin();			block3.reSkin();			block4.reSkin();		}						public function yellow():void {			this.color = "yellow";			resetBlockColors();		}		public function red():void {			this.color = "red";			resetBlockColors();		}		public function blue():void {			this.color = "blue";			resetBlockColors();					}				public function updateColors(newBlocks:Array){			block1 = newBlocks[0];			block2 = newBlocks[1];			block3 = newBlocks[2];			block4 = newBlocks[3];			blockArray = [block1, block2, block3, block4];			reSkinBlocks();			init();		}	}}
package {	import flash.display.Sprite;	import flash.events.MouseEvent;	import flash.events.Event;		import flashx.textLayout.formats.BlockProgression;	import flash.utils.getQualifiedClassName;	import flash.utils.getDefinitionByName;		import blocks.BasicBlock;	import blocks.BlueBlock;	import blocks.GreenBlock;	import blocks.OrangeBlock;	import blocks.PurpleBlock;	import blocks.RedBlock;	import blocks.WhiteBlock;	import blocks.YellowBlock;	public class PlayBoard extends Sprite {		//this variable will control what the board does in updating		public var condition:String;		/*inactive - waiting for the opponent to move		 *ready - waiting for the player to pick up a piece		 *dropping - updating the players piece position/colors		 *activating - player can activate a block		*/		//array to hold the play tiles		public var playArray:Array;		//block to which the players piece is snapped		public var snappedBlock:Object;		//rows and columns		public var rows:uint;		public var cols:uint;		//reference to main		public var main:Prototype;		public function PlayBoard(main:Prototype,cols:uint, rows:uint) {			this.main = main;			condition = "inactive";			this.rows = rows;			this.cols = cols;			this.scaleX = .3;			this.scaleY = .3;			addEventListener(Event.ADDED_TO_STAGE, init);		}		public function init(evt:Event):void {			removeEventListener(Event.ADDED_TO_STAGE, init);			buildArrays();			//position myself			this.x = stage.width / 2 - this.width / 2;			this.y = stage.height / 2;		}		public function buildArrays():void {			//reset the arrays			playArray = new Array();			//make the second dimension of the arrays			for (var c:uint = 0; c < cols; c++) {				playArray.push(new Array());			}			//populate the arrays			for (c = 0; c < cols; c++) {				for (var r:uint = 0; r < rows; r++) {					playArray[r].push(new BasicBlock());					playArray[r][c].x = playArray[r][c].width * r;					playArray[r][c].y = playArray[r][c].height * c;					playArray[r][c].boardX = r;					playArray[r][c].boardY = c;					addChild(playArray[r][c]);				}			}		}		//the main function will call this when player picks up a piece		public function dropReady():void {			condition = "dropping";			for (var r:uint = 0; r < rows; r++) {				for (var c:uint = 0; c < cols; c++) {					playArray[r][c].mouseEnabled = true;					playArray[r][c].addEventListener(MouseEvent.MOUSE_OVER, snapBlock);				}			}		}		public function dropPiece(shape:QuadShape):void {			condition = "ready";			for (var r:uint = 0; r < rows; r++) {				for (var c:uint = 0; c < cols; c++) {					playArray[r][c].removeEventListener(MouseEvent.MOUSE_OVER, snapBlock);				}			}			var coordinates:Array = shape.blockCoordinates();			var shapeX:int = snappedBlock.x / snappedBlock.width;			var shapeY:int = snappedBlock.y / snappedBlock.height;			var xCoordinate:int;			var yCoordinate:int;			var newBlock:BasicBlock;			var newClass:Class;						for (var block:uint = 0; block < 4; block++) {				xCoordinate = coordinates[block].x + shapeX;				yCoordinate = coordinates[block].y + shapeY;				if (yCoordinate >= 0 && yCoordinate < rows && xCoordinate >= 0 && xCoordinate < cols) {					removeChild(playArray[xCoordinate][yCoordinate]);					trace(shape.blockArray[block].blockClass);					trace(shape.blockArray[block]);					newBlock = new shape.blockArray[block].blockClass();					//trying to fix the grid position issue					newBlock.mouseChildren = false;					newBlock.x = xCoordinate * newBlock.width;					newBlock.y = yCoordinate * newBlock.height;					newBlock.boardX = xCoordinate;					newBlock.boardY = yCoordinate;					newBlock.mouseEnabled = true;					playArray[xCoordinate][yCoordinate] = newBlock;					addChild(playArray[xCoordinate][yCoordinate]);				}			}		}		public function snapBlock(evt:MouseEvent):void {			snappedBlock = evt.target;			main.currentPiece.x = this.x + snappedBlock.width * snappedBlock.boardX * this.scaleX;			main.currentPiece.y = this.y + snappedBlock.height * snappedBlock.boardY * this.scaleY;			trace(snappedBlock.boardX," ", snappedBlock.boardY);			updateBlockColors();		}		public function updateBlockColors():void {			var shape:QuadShape = main.currentPiece;			var coordinates:Array = shape.blockCoordinates();			var shapeX:int = snappedBlock.x / snappedBlock.width;			var shapeY:int = snappedBlock.y / snappedBlock.height;			var playXcoordinate:int;			var playYcoordinate:int;			var newBlocks:Array = new Array();			for (var block:uint = 0; block < 4; block++) {				playXcoordinate = shapeX + coordinates[block].x;				playYcoordinate = shapeY + coordinates[block].y;				if (shape.color == "red") {					if (playXcoordinate >= 0 && playXcoordinate < cols && playYcoordinate >= 0 && playYcoordinate < rows) {						if (playArray[playXcoordinate][playYcoordinate] is BlueBlock) {							newBlocks.push(new PurpleBlock());						} else if (playArray[playXcoordinate][playYcoordinate] is YellowBlock) {							newBlocks.push(new OrangeBlock());						} else if (playArray[playXcoordinate][playYcoordinate] is GreenBlock) {							newBlocks.push(new WhiteBlock());						} else {							newBlocks.push(new RedBlock());						}					} else {						newBlocks.push(new RedBlock());					}				} else if (shape.color == "yellow") {					if (playXcoordinate >= 0 && playXcoordinate < cols && playYcoordinate >= 0 && playYcoordinate < rows) {						if (playArray[playXcoordinate][playYcoordinate] is RedBlock) {							newBlocks.push(new OrangeBlock());						} else if (playArray[playXcoordinate][playYcoordinate] is BlueBlock) {							newBlocks.push(new GreenBlock());						} else if (playArray[playXcoordinate][playYcoordinate] is PurpleBlock) {							newBlocks.push(new WhiteBlock());						} else {							newBlocks.push(new YellowBlock());						}					} else {						newBlocks.push(new YellowBlock());					}				} else if (shape.color == "blue") {					if (playXcoordinate >= 0 && playXcoordinate < cols && playYcoordinate >= 0 && playYcoordinate < rows) {						if (playArray[playXcoordinate][playYcoordinate] is RedBlock) {							newBlocks.push(new PurpleBlock());						} else if (playArray[playXcoordinate][playYcoordinate] is YellowBlock) {							newBlocks.push(new GreenBlock());						} else if (playArray[playXcoordinate][playYcoordinate] is OrangeBlock) {							newBlocks.push(new WhiteBlock());						} else {							newBlocks.push(new BlueBlock());						}					} else {						newBlocks.push(new BlueBlock());					}				}			}			shape.updateColors(newBlocks);		}	}}
package {	import flash.display.Sprite;	import flash.events.MouseEvent;	import flash.events.Event;	import flashx.textLayout.formats.BlockProgression;	import flash.utils.getQualifiedClassName;	import flash.utils.getDefinitionByName;	public class PlayBoard extends Sprite {		//this variable will control what the board does in updating		public var condition:String;		/*inactive - waiting for the opponent to move		 *ready - waiting for the player to pick up a piece		 *dropping - updating the players piece position/colors		 *activating - player can activate a block		*/		//array to hold the play tiles		public var playArray:Array;		//block to which the players piece is snapped		public var snappedBlock:Object;		//rows and columns		public var rows:uint;		public var cols:uint;		//reference to main		public var main:Prototype;		public function PlayBoard(main:Prototype,cols:uint, rows:uint) {			this.main = main;			condition = "inactive";			this.rows = rows;			this.cols = cols;			this.scaleX = .3;			this.scaleY = .3;			addEventListener(Event.ADDED_TO_STAGE, init);		}		public function init(evt:Event):void {			removeEventListener(Event.ADDED_TO_STAGE, init);			buildArrays();			//position myself			this.x = stage.width / 2 - this.width / 2;			this.y = stage.height / 2;		}		public function buildArrays():void {			//reset the arrays			playArray = new Array();			//make the second dimension of the arrays			for (var c:uint = 0; c < cols; c++) {				playArray.push(new Array());			}			//populate the arrays			var newBlock:BasicBlock;			for (c = 0; c < cols; c++) {				for (var r:uint = 0; r < rows; r++) {					playArray[r].push(new BasicBlock());					newBlock = playArray[r][c];					newBlock.x = main.blockSize * r;					newBlock.y = main.blockSize * c;					newBlock.boardX = r;					newBlock.boardY = c;					newBlock.scaleX *= main.blockSize/newBlock.width;					newBlock.scaleY *= main.blockSize/newBlock.height;					addChild(newBlock);				}			}		}		//the main function will call this when player picks up a piece		public function dropReady():void {			condition = "dropping";			for (var r:uint = 0; r < rows; r++) {				for (var c:uint = 0; c < cols; c++) {					playArray[r][c].mouseEnabled = true;					playArray[r][c].addEventListener(MouseEvent.MOUSE_OVER, snapBlock);				}			}		}		public function dropPiece(shape:QuadShape):void {			//updateBlockColors();			condition = "ready";			for (var r:uint = 0; r < rows; r++) {				for (var c:uint = 0; c < cols; c++) {					playArray[r][c].removeEventListener(MouseEvent.MOUSE_OVER, snapBlock);				}			}			var xCoordinate:int;			var yCoordinate:int;			var newBlock:BasicBlock;			var newClass:Class;			for (var i:uint = 0; i < 4; i++) {				xCoordinate = shape.blockArray[i].boardX + snappedBlock.boardX;				yCoordinate = shape.blockArray[i].boardY + snappedBlock.boardY;				if (yCoordinate >= 0 && yCoordinate < rows && xCoordinate >= 0 && xCoordinate < cols) {					removeChild(playArray[xCoordinate][yCoordinate]);					newBlock = new shape.blockArray[i].blockClass();					newBlock.mouseChildren = false;					newBlock.x = xCoordinate * main.blockSize;					newBlock.y = yCoordinate * main.blockSize;					newBlock.boardX = xCoordinate;					newBlock.boardY = yCoordinate;					newBlock.mouseEnabled = true;					playArray[xCoordinate][yCoordinate] = newBlock;					addChild(playArray[xCoordinate][yCoordinate]);				}			}		}		public function snapBlock(evt:MouseEvent):void {			snappedBlock = evt.target;			main.currentPiece.x = this.x + snappedBlock.width * snappedBlock.boardX * this.scaleX;			main.currentPiece.y = this.y + snappedBlock.height * snappedBlock.boardY * this.scaleY;			updateBlockColors();		}		public function updateBlockColors():void {			var shape:QuadShape = main.currentPiece;			var shapeX:int = snappedBlock.x / main.blockSize;			var shapeY:int = snappedBlock.y / main.blockSize;			var playXcoordinate:int;			var playYcoordinate:int;			var newBlocks:Array = new Array();			var boardBlock:BasicBlock;			for (var block:uint = 0; block < 4; block++) {				playXcoordinate = shapeX + shape.blockArray[block].boardX;				playYcoordinate = shapeY + shape.blockArray[block].boardY;				//if the block is in play				if (playXcoordinate >= 0 && playXcoordinate < cols && playYcoordinate >= 0 && playYcoordinate < rows) {					boardBlock = playArray[playXcoordinate][playYcoordinate];					if (shape.color == "red") {						if (boardBlock is BlueBlock) {//red and blue -> purple							newBlocks.push(new PurpleBlock());						} else if (boardBlock is YellowBlock) {							newBlocks.push(new OrangeBlock());							//red and yellow -> orange						} else if (boardBlock is GreenBlock) {							newBlocks.push(new WhiteBlock());							//red and green -> white						} else if (boardBlock.blockClass == BasicBlock) {							newBlocks.push(new RedBlock());							//red on its own is red						} else {//the last condition is a nonreactive color, so grab that color							newBlocks.push( new boardBlock.blockClass());						}					} else if (shape.color == "yellow") {						if (boardBlock is RedBlock) {							newBlocks.push(new OrangeBlock());						} else if (boardBlock is BlueBlock) {							newBlocks.push(new GreenBlock());						} else if (boardBlock is PurpleBlock) {							newBlocks.push(new WhiteBlock());						} else if (boardBlock.blockClass == BasicBlock) {							newBlocks.push(new YellowBlock());						} else {							//the last condition is a nonreactive color, so grab that color							newBlocks.push( new boardBlock.blockClass());						}					} else if (shape.color == "blue") {						if (boardBlock is RedBlock) {							newBlocks.push(new PurpleBlock());						} else if (boardBlock is YellowBlock) {							newBlocks.push(new GreenBlock());						} else if (boardBlock is OrangeBlock) {							newBlocks.push(new WhiteBlock());						} else if (boardBlock.blockClass == BasicBlock) {							newBlocks.push(new BlueBlock());						} else {							//the last condition is a nonreactive color, so grab that color							newBlocks.push( new boardBlock.blockClass());						}					}				}else {					newBlocks.push(new BasicBlock());				}							}			shape.updateColors(newBlocks);		}	}}
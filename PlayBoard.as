package {	import flash.display.Sprite;	import flash.events.MouseEvent;	import flash.events.Event;	import flashx.textLayout.formats.BlockProgression;	import flash.utils.getQualifiedClassName;	import flash.utils.getDefinitionByName;	public class PlayBoard extends Sprite {		//array to hold the play tiles		public var playArray:Array;		//block to which the players piece is snapped		public var snappedBlock:Object;		//rows and columns		public var rows:uint;		public var cols:uint;		//reference to main		public var main:Prototype;		public function PlayBoard(main:Prototype,cols:uint, rows:uint) {			this.main = main;			this.rows = rows;			this.cols = cols;			this.scaleX = .3;			this.scaleY = .3;			addEventListener(Event.ADDED_TO_STAGE, init);		}		public function init(evt:Event):void {			removeEventListener(Event.ADDED_TO_STAGE, init);			buildArrays();			//position myself			this.x = stage.width / 2 - this.width / 2;			this.y = stage.height / 2;		}		public function buildArrays():void {			//reset the arrays			playArray = new Array();			//make the second dimension of the arrays			for (var c:uint = 0; c < cols; c++) {				playArray.push(new Array());			}			//populate the arrays			var newBlock:Block;			for (c = 0; c < cols; c++) {				for (var r:uint = 0; r < rows; r++) {					playArray[r].push(new Block());					newBlock = playArray[r][c];					newBlock.x = main.blockSize * r;					newBlock.y = main.blockSize * c;					newBlock.boardX = r;					newBlock.boardY = c;					newBlock.scaleX *=  main.blockSize / newBlock.width;					newBlock.scaleY *=  main.blockSize / newBlock.height;					addChild(newBlock);				}			}		}		//the main function will call this when player picks up a piece		public function dropReady():void {			for (var r:uint = 0; r < rows; r++) {				for (var c:uint = 0; c < cols; c++) {					playArray[r][c].mouseEnabled = true;					playArray[r][c].mouseChildren = false;					playArray[r][c].addEventListener(MouseEvent.MOUSE_OVER, snapBlock);				}			}		}		public function dropPiece(shape:QuadShape):void {			for (var r:uint = 0; r < rows; r++) {				for (var c:uint = 0; c < cols; c++) {					playArray[r][c].removeEventListener(MouseEvent.MOUSE_OVER, snapBlock);				}			}			var xCoordinate:int;			var yCoordinate:int;			var newBlock:Block;			var newClass:Class;			for (var i:uint = 0; i < 4; i++) {				xCoordinate = shape.blockArray[i].boardX + snappedBlock.boardX;				yCoordinate = shape.blockArray[i].boardY + snappedBlock.boardY;				if (yCoordinate >= 0 && yCoordinate < rows && xCoordinate >= 0 && xCoordinate < cols) {					removeChild(playArray[xCoordinate][yCoordinate]);					newBlock = new Block();					newBlock.type = shape.blockArray[i].type;					newBlock.reSkin();					newBlock.mouseChildren = false;					newBlock.x = xCoordinate * main.blockSize;					newBlock.y = yCoordinate * main.blockSize;					newBlock.boardX = xCoordinate;					newBlock.boardY = yCoordinate;					newBlock.mouseEnabled = true;					playArray[xCoordinate][yCoordinate] = newBlock;					addChild(playArray[xCoordinate][yCoordinate]);				}			}			activateReady();		}		public function activateReady():void {			for (var r:uint = 0; r < rows; r++) {				for (var c:uint = 0; c < cols; c++) {					playArray[r][c].addEventListener(MouseEvent.MOUSE_DOWN, activateBlock);				}			}		}		public function activateBlock(evt:Event):void {			for (var r:uint = 0; r < rows; r++) {				for (var c:uint = 0; c < cols; c++) {					playArray[r][c].removeEventListener(MouseEvent.MOUSE_DOWN, activateBlock);				}			}			var frontier:Array = new Array();			var found:int = 0;			var targetBlock:Block = evt.target as Block;			var targetType:String = targetBlock.type;			var neighborBlock:Block;			var tx:int;			var ty:int;			if (targetType != "basic") {				frontier.push(targetBlock);				basicizeBlock(targetBlock);			}			//find blocks			while (frontier.length > 0) {				targetBlock = frontier.pop();				found += 1;				tx = targetBlock.boardX;				ty = targetBlock.boardY;				//up				if (ty - 1 >= 0) {					neighborBlock = playArray[tx][ty - 1];					if (neighborBlock.type == targetType && neighborBlock.found == false) {						frontier.push(neighborBlock);						basicizeBlock(neighborBlock);					}				}				//left				if (tx - 1 >= 0) {					neighborBlock = playArray[tx - 1][ty];					if (neighborBlock.type == targetType && neighborBlock.found == false) {						frontier.push(neighborBlock);						basicizeBlock(neighborBlock);					}				}				if (ty + 1 < rows) {					neighborBlock = playArray[tx][ty + 1];					if (neighborBlock.type == targetType && neighborBlock.found == false) {						frontier.push(neighborBlock);						basicizeBlock(neighborBlock);					}				}				if (tx + 1 < cols) {					neighborBlock = playArray[tx + 1][ty];					if (neighborBlock.type == targetType && neighborBlock.found == false) {						frontier.push(neighborBlock);						basicizeBlock(neighborBlock);					}				}			}			main.playerEffects.activate(targetType, found);		}				//turns the block into basicBlock && finds it		public function basicizeBlock(block:Block):void{			block.type = "basic";			block.reSkin();		}						public function snapBlock(evt:MouseEvent):void {			snappedBlock = evt.target;			//trace(snappedBlock.boardX, " ", snappedBlock.boardY);			main.currentPiece.x = this.x + snappedBlock.width * snappedBlock.boardX * this.scaleX;			main.currentPiece.y = this.y + snappedBlock.height * snappedBlock.boardY * this.scaleY;			updateBlockColors();		}		public function updateBlockColors():void {			var shape:QuadShape = main.currentPiece;			var shapeX:int = snappedBlock.x / main.blockSize;			var shapeY:int = snappedBlock.y / main.blockSize;			var playXcoordinate:int;			var playYcoordinate:int;			var newBlocks:Array = new Array();			var boardBlock:Block;			var newBlock:Block;			for (var block:uint = 0; block < 4; block++) {				playXcoordinate = shapeX + shape.blockArray[block].boardX;				playYcoordinate = shapeY + shape.blockArray[block].boardY;				//if the block is in play				newBlock = new Block();				if (playXcoordinate >= 0 && playXcoordinate < cols && playYcoordinate >= 0 && playYcoordinate < rows) {					boardBlock = playArray[playXcoordinate][playYcoordinate];					if (shape.color == "red") {						if (boardBlock.type == "blue") {//red and blue -> purple							newBlock.type = "purple";						} else if (boardBlock.type == "yellow") {							newBlock.type = "orange";							//red and yellow -> orange						} else if (boardBlock.type == "green") {							newBlock.type = "white";							//red and green -> white						} else if (boardBlock.type == "basic") {							newBlock.type = "red";							//red on its own is red						} else {//the last condition is a nonreactive color, so grab that color							newBlock.type = boardBlock.type;						}					} else if (shape.color == "yellow") {						if (boardBlock.type == "red") {							newBlock.type = "orange";						} else if (boardBlock.type == "blue") {							newBlock.type = "green";						} else if (boardBlock.type == "purple") {							newBlock.type = "white";						} else if (boardBlock.type == "basic") {							newBlock.type = "yellow";						} else {							//the last condition is a nonreactive color, so grab that color							newBlock.type = boardBlock.type;						}					} else if (shape.color == "blue") {						if (boardBlock.type == "red") {							newBlock.type = "purple";						} else if (boardBlock.type == "yellow") {							newBlock.type = "green";						} else if (boardBlock.type == "orange") {							newBlock.type = "white";						} else if (boardBlock.type == "basic") {							newBlock.type = "blue";						} else {							//the last condition is a nonreactive color, so grab that color							newBlock.type = boardBlock.type;						}					}				} else {					newBlock.type = "dead";				}				newBlocks.push(newBlock);			}			shape.updateColors(newBlocks);		}	}}